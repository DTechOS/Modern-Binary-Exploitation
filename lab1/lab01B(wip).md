## File Description:
```
lab1B: ELF 32-bit LSB executable, Intel 80386, BuildID[sha1]=c9f07b581bd8d97cdc7c0ff1a288e20aea2df0f5, stripped
```
test():

Decrypt():
```

int decrypt(EVP_PKEY_CTX *ctx,uchar *out,size_t *outlen,uchar *in,size_t inlen)

{
  size_t key_len;
  int result_EAX;
  int in_GS_OFFSET;
  uint i;
  undefined4 enc_string;
  undefined4 local_1d;
  undefined4 local_19;
  undefined4 local_15;
  undefined local_11;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  enc_string = 0x757c7d51;
  local_1d = 0x67667360;
  local_19 = 0x7b66737e;
  local_15 = 0x33617c7d;
  local_11 = 0;
  key_len = strlen((char *)&enc_string);
  for (i = 0; i < key_len; i = i + 1) {
    *(byte *)((int)&enc_string + i) = (byte)ctx ^ *(byte *)((int)&enc_string + i);
  }
  result_EAX = strcmp((char *)&enc_string,"Congratulations!");
  if (result_EAX == 0) {
    system("/bin/sh");
  }
  else {
    puts("\nInvalid Password!");
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return 0;
  }
                    /* WARNING: Subroutine does not return */
  __stack_chk_fail();
}



```

It moves a string onto the stack to be passed through some artithmetic later in the program
```
local_10 = *(int *)(in_GS_OFFSET + 0x14);
  maybe_key = 0x757c7d51;
  local_1d = 0x67667360;
  local_19 = 0x7b66737e;
  local_15 = 0x33617c7d;
  local_11 = 0;
```
stepping through the mov instructions in gdb reveals the full string it moves onto the stack
```
02:0008│     0xffffcf38 —▸ 0xffffcf98 —▸ 0xffffcfc8 —▸ 0xf7ffd020 (_rtld_global) —▸ 0xf7ffda40 ◂— ...
03:000c│     0xffffcf3c —▸ 0xf7c3a34e (random+62) ◂— xor    eax, eax
04:0010│     0xffffcf40 —▸ 0xf7e214a4 (unsafe_state) —▸ 0xf7e21094 (randtbl+20) ◂— 0xf8e7f53a
05:0014│     0xffffcf44 —▸ 0xffffcf58 ◂— 0x33617c /* '|a3' */
06:0018│     0xffffcf48 ◂— 0x51ffd084
07:001c│     0xffffcf4c ◂— 'Q}|u`sfg~sf{}|a3'
```


## Decryption Logic:

the string that was moved onto the stack is passed into strlen
```
   key_len = strlen((char *)&enc_string);
  for (i = 0; i < key_len; i = i + 1) {
    *(byte *)((int)&enc_string + i) = (byte)ctx ^ *(byte *)((int)&enc_string + i);
  }
  result_EAX = strcmp((char *)&enc_string,"Congratulations!");
  if (result_EAX == 0) {
    system("/bin/sh");
  }
  else {
    puts("\nInvalid Password!");
  }
```

The xor operation in disassembly:

```
0x8048a18 <decrypt+97>     xor    eax, edx
```

The value on in edx on this instruction is 0x51, the first character in the encrypted string that was stored on the stack.
```
eax            0x2d285c4a          757619786
ecx            0xb                 11
edx            0x51 
```





Solution:

```
# result_EAX = strcmp((char *)&enc_string,"Congratulations!"); strcmp, compares the result of our imput after 
#being passed through the xor arithmetic
# we need to find a key that when xored with the encrypted string = # xor eax,edx
# 0x51 = Q, first character of the encrypted string, C = first character of Congratulations!
               
key = ord('C') ^ 0x51 
print("Xor key: {}".format(key))                        

# in test() the contant 0x1337d00d is moved onto the stack, decrypt() is then performed and the program attempts to decrypt
#   a string with input - 0x1337d00d
password = 0x1337d00d - key
print("Challenge password: {}".format(password))

# XOR'ing the encrypted string with the key 18 returns Congratulations!, so when it is passed into strcmp((char *)&enc_string,"Congratulations!"); 
# the return value is true and the program authenticates 
xor_key = 18
s1 = "Q}|u`sfg~sf{}|a3"
for i in range(len(s1)):
    res = chr(ord(s1[i]) ^ xor_key) 
    print(res, end='')
```
Output:
```
Xor key: 18
Challenge password: 322424827
Congratulations!
```

