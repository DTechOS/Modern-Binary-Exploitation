## File Description:
```
lab1B: ELF 32-bit LSB executable, Intel 80386, BuildID[sha1]=c9f07b581bd8d97cdc7c0ff1a288e20aea2df0f5, stripped
```

## Static Analysis:

Decrypt(): 0x080489b7

I've already renamed some of the renamed some of the variables
```

int decrypt(EVP_PKEY_CTX *ctx,uchar *out,size_t *outlen,uchar *in,size_t inlen)

{
  size_t key_len;
  int result_EAX;
  int in_GS_OFFSET;
  uint i;
  undefined4 enc_string;
  undefined4 local_1d;
  undefined4 local_19;
  undefined4 local_15;
  undefined local_11;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  enc_string = 0x757c7d51;
  local_1d = 0x67667360;
  local_19 = 0x7b66737e;
  local_15 = 0x33617c7d;
  local_11 = 0;
  key_len = strlen((char *)&enc_string);
  for (i = 0; i < key_len; i = i + 1) {
    *(byte *)((int)&enc_string + i) = (byte)ctx ^ *(byte *)((int)&enc_string + i);
  }
  result_EAX = strcmp((char *)&enc_string,"Congratulations!");
  if (result_EAX == 0) {
    system("/bin/sh");
  }
  else {
    puts("\nInvalid Password!");
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return 0;
  }
                    /* WARNING: Subroutine does not return */
  __stack_chk_fail();
}



```

It moves a string onto the stack to be passed through some artithmetic later in the program
```
local_10 = *(int *)(in_GS_OFFSET + 0x14);
  maybe_key = 0x757c7d51;
  local_1d = 0x67667360;
  local_19 = 0x7b66737e;
  local_15 = 0x33617c7d;
  local_11 = 0;
```
stepping through the mov instructions in gdb reveals the full string it moves onto the stack
```
02:0008│     0xffffcf38 —▸ 0xffffcf98 —▸ 0xffffcfc8 —▸ 0xf7ffd020 (_rtld_global) —▸ 0xf7ffda40 ◂— ...
03:000c│     0xffffcf3c —▸ 0xf7c3a34e (random+62) ◂— xor    eax, eax
04:0010│     0xffffcf40 —▸ 0xf7e214a4 (unsafe_state) —▸ 0xf7e21094 (randtbl+20) ◂— 0xf8e7f53a
05:0014│     0xffffcf44 —▸ 0xffffcf58 ◂— 0x33617c /* '|a3' */
06:0018│     0xffffcf48 ◂— 0x51ffd084
07:001c│     0xffffcf4c ◂— 'Q}|u`sfg~sf{}|a3'
```


Decryption Logic:

the string that was moved onto the stack is passed into strlen
```
  for (i = 0; i < key_len; i = i + 1) {
    *(byte *)((int)&enc_string + i) = (byte)ctx ^ *(byte *)((int)&enc_string + i);
  }
  result_EAX = strcmp((char *)&enc_string,"Congratulations!");
  if (result_EAX == 0) {
    system("/bin/sh");
  }
```

The xor operation in disassembly:

```
0x8048a18 <decrypt+97>     xor    eax, edx


```




```
*(byte *)((int)&maybe_key + i) = (byte)ctx ^ *(byte *)((int)&maybe_key + i);
```




Solution:

```
key_test = ord('C') ^ 0x51 # 0x51 = Q, first character of the encrypted string, C = first character of Congratulations!
                           # result_EAX = strcmp((char *)&enc_string,"Congratulations!"); strcmp, compares the result of our imput after
                           # being passed through the arithmetic to the string Congratulations!
print(key_test)

password = 0x1337d00d - key_test # this result is the challenge password
print(password)

# XOR'ing the encrypted string with the key 18 returns 
key = 18
s1 = "Q}|u`sfg~sf{}|a3"
s2 = "Congratulations!"

for i in range(len(s1)):
    res = chr(ord(s1[i]) ^ 18) 
    print(res, end='')
```
Output:
```
18
322424827 # password
Congratulations!
```

