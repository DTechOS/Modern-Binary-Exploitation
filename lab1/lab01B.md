## File Description:
```
lab1B: ELF 32-bit LSB executable, Intel 80386, BuildID[sha1]=c9f07b581bd8d97cdc7c0ff1a288e20aea2df0f5, stripped
```

## Static Analysis:

Decrypt(): 0x080489b7

I've already renamed some of the renamed some of the variables
```
int decrypt(EVP_PKEY_CTX *ctx,uchar *out,size_t *outlen,uchar *in,size_t inlen)

{
  size_t key_len;
  int result;
  int in_GS_OFFSET;
  uint i;
  undefined4 maybe_key;
  undefined4 local_1d;
  undefined4 local_19;
  undefined4 local_15;
  undefined local_11;
  int local_10;
  
  local_10 = *(int *)(in_GS_OFFSET + 0x14);
  maybe_key = 0x757c7d51;
  local_1d = 0x67667360;
  local_19 = 0x7b66737e;
  local_15 = 0x33617c7d;
  local_11 = 0;
  key_len = strlen((char *)&maybe_key);
  for (i = 0; i < key_len; i = i + 1) {
    *(byte *)((int)&maybe_key + i) = (byte)ctx ^ *(byte *)((int)&maybe_key + i);
  }
  result = strcmp((char *)&maybe_key,"Congratulations!");
  if (result == 0) {
    system("/bin/sh");
  }
  else {
    puts("\nInvalid Password!");
  }
  if (local_10 == *(int *)(in_GS_OFFSET + 0x14)) {
    return 0;
  }
                    /* WARNING: Subroutine does not return */
  __stack_chk_fail();
}

```
It moves some strings and I think a key onto the stack 
```
local_10 = *(int *)(in_GS_OFFSET + 0x14);
  maybe_key = 0x757c7d51;
  local_1d = 0x67667360;
  local_19 = 0x7b66737e;
  local_15 = 0x33617c7d;
  local_11 = 0;
```
It iterates through each byte in the key and the user provided password and compares that to some value on the stack     
It XOR's the value on the stack with a 
```
for (i = 0; i < key_len; i = i + 1) {
    *(byte *)((int)&maybe_key + i) = (byte)ctx ^ *(byte *)((int)&maybe_key + i);
  }
  result = strcmp((char *)&maybe_key,"Congratulations!");
  if (result == 0) {
    system("/bin/sh");
  }
```

```
*(byte *)((int)&maybe_key + i) = (byte)ctx ^ *(byte *)((int)&maybe_key + i);
```








- Breakpoint 1: Decrypt()
- Breakpoint2(0x08048a18): XOR  key_len,EDX
- Breakpoint 3: 0x08048a2b <+116>:   cmp    eax,DWORD PTR [ebp-0x24]
- Breakpoint 4: 0x08048a43 <+140>:   test   eax,eax



Run the binary in gdb and enter any password until the 1st breakpoint is hit, it moves the stack string 0x1337d00d into esp.
```
00:0000│ esp 0xffffcf6c —▸ 0x8048be2 (test+366) ◂— leave  
01:0004│     0xffffcf70 ◂— 0x5338437a ('zC8S')
02:0008│     0xffffcf74 —▸ 0xf7ffcb80 (_rtld_global_ro) ◂— 0x0
03:000c│     0xffffcf78 —▸ 0xffffcfc8 —▸ 0xf7ffd020 (_rtld_global) —▸ 0xf7ffda40 ◂— 0x0
04:0010│     0xffffcf7c —▸ 0xf7c572b5 (__isoc99_scanf+37) ◂— add    esp, 0x1c
05:0014│     0xffffcf80 —▸ 0xf7e21620 (_IO_2_1_stdin_) ◂— 0xfbad2288
06:0018│     0xffffcf84 —▸ 0x8048dee ◂— and    eax, 0x64 /* '%d' */
07:001c│     0xffffcf88 —▸ 0xffffcfa4 ◂— 0x1337d00d

```
Solution:

```
key_test = ord('C') ^ 0x51 # 0x51 = Q, first character of the encrypted string, C = first character of Congratulations!
                           # result_EAX = strcmp((char *)&enc_string,"Congratulations!"); strcmp, compares the result of our imput after
                           # being passed through the arithmetic to the string Congratulations!
print(key_test)

password = 0x1337d00d - key_test # this result is the challenge password
print(password)

# XOR'ing the encrypted string with the key 18 returns 
key = 18
s1 = "Q}|u`sfg~sf{}|a3"
s2 = "Congratulations!"

for i in range(len(s1)):
    res = chr(ord(s1[i]) ^ 18) 
    print(res, end='')
```
Output:
```
18
322424827 # password
Congratulations!
```

