# Lab1A

File Type:
``` 
ELF 32-bit LSB executable, Intel 80386
```

---------------------- Static Analysis----------------------

It creates a character buffer of 32 bytes
```
  int iVar1;
  int in_GS_OFFSET;
  char local_34 [32];
  int local_14;
```


iVaris assigned the return value of the auth() function, which is then stored in EAX,
if EAX is 0 then it prints "Authenticated" then spawns a shell on the system.
```
  iVar1 = auth();
  if (iVar1 == 0) {
    puts("Authenticated!");
    system("/bin/sh");
  }
```
TEST EAX,EAX = if (iVar1 == 0)
```
CALL       auth       undefined auth(undefined4 param_
TEST       EAX,EAX 
JNZ        LAB_08048c55
MOV        dword ptr [ESP]=>local_4c,s_Authenticated!_080   = "Authenticated!"
       
CALL       <EXTERNAL>::puts                                 int puts(char * __s)
   
MOV        dword ptr [ESP]=>local_4c,s_/bin/sh_08048e72     = "/bin/sh"

CALL       <EXTERNAL>::system                               int system(char * __command)
ff ff

```
-----------Exploitation Method 1--------------------

The first way to exploit this is just give it some input, put a breakpoint on the TEST EAX,EAX instruction, then set EAX to 0,
then it should run the call to puts() then system() and spawn a shell. However I don't think this is the intended solution since,
the actual objective is to reverse engineer the auth() function and find the correct password.


Method 1, The easy way

1. run the binary in GDB

2. 

