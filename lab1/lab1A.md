Lab1A

File Type:
``` 
ELF 32-bit LSB executable, Intel 80386
```

---------------------- Static Analysis----------------------

It creates a character buffer of 32 bytes
```
  int iVar1;
  int in_GS_OFFSET;
  char local_34 [32];
  int local_14;
```


iVaris assigned the return value of the auth() function, which is then stored in EAX,
if EAX is 0 then it prints "Authenticated" then spawns a shell on the system.
```
  iVar1 = auth();
  if (iVar1 == 0) {
    puts("Authenticated!");
    system("/bin/sh");
  }
```
TEST EAX,EAX = if (iVar1 == 0)
```
CALL       auth       undefined auth(undefined4 param_
TEST       EAX,EAX 
JNZ        LAB_08048c55
MOV        dword ptr [ESP]=>local_4c,s_Authenticated!_080   = "Authenticated!"
       
CALL       <EXTERNAL>::puts                                 int puts(char * __s)
   
MOV        dword ptr [ESP]=>local_4c,s_/bin/sh_08048e72     = "/bin/sh"

CALL       <EXTERNAL>::system                               int system(char * __command)
ff ff

```
-----------Exploitation Method 1--------------------

The first way to exploit this is just give it some input, put a breakpoint on the TEST EAX,EAX instruction, then set EAX to 0,
then it should run the call to puts() then system() and spawn a shell. However I don't think this is the intended solution since,
the actual objective is to reverse engineer the auth() function and find the correct password.


Method 1, The easy way

1. run the binary in GDB

2. Put a breakpoint on the test instruction at 0x8048c32 and the ret at 0x8048c6d

3. Run the binary until it hits the test instruction, set eax to 0 using "set $eax=0"

We get the ouput 

```
Authenticated!
Starting program: /usr/bin/dash 
```
It tried to run /bin/dash however were still in our debugger and it didnt actually spawn a shell.
Lets try reversing the auth() function and see if we cant genereate a valid username or serial


auth()

To generate a valid serial from the username that we supplied, it seeds the serial generation with local_14 = ((int)param_1[3] ^ 0x1337U) + 0x5eeded;
then iterates over every character and performs the arithmetic local_14 = local_14 + ((int)param_1[local_18] ^ local_14) % 1337
```
  sVar1 = strcspn(param_1,"\n");
  param_1[sVar1] = '\0';
  sVar1 = strnlen(param_1,32);
  if ((int)sVar1 < 6) {
    uVar2 = 1;
  }
  else {
    lVar3 = ptrace(PTRACE_TRACEME);
    if (lVar3 == -1) {
      puts("\x1b[32m.---------------------------.");
      puts("\x1b[31m| !! TAMPERING DETECTED !!  |");
      puts("\x1b[32m\'---------------------------\'");
      uVar2 = 1;
    }
    else {
      local_14 = ((int)param_1[3] ^ 0x1337U) + 0x5eeded;
      for (local_18 = 0; local_18 < (int)sVar1; local_18 = local_18 + 1) {
        if (param_1[local_18] < ' ') {
          return 1;
        }
        local_14 = local_14 + ((int)param_1[local_18] ^ local_14) % 1337;
      }
```

```
        08048aff 89 c1           MOV        ECX,username
        08048b01 ba 2b 3b        MOV        EDX,0x88233b2b
                 23 88
        08048b06 89 c8           MOV        username,ECX
        08048b08 f7 e2           MUL        EDX
        08048b0a 89 c8           MOV        username,ECX
        08048b0c 29 d0           SUB        username,EDX
        08048b0e d1 e8           SHR        username,0x1
        08048b10 01 d0           ADD        username,EDX
        08048b12 c1 e8 0a        SHR        username,0xa
        08048b15 69 c0 39        IMUL       username,username,0x539
                 05 00 00
```


With full renamed variables from pseudo-code.
we can use any username under 32 characters. we just need to write a script to perform the same arithmetic on whatever username we choose.

```
{
  size_t username;
  undefined4 uVar1;
  long lVar2;
  int local_18;
  uint serial;
  
  username = strcspn(param_1,"\n");
  param_1[username] = '\0';
  username = strnlen(param_1,32);
  if ((int)username < 6) {
    uVar1 = 1;
  }
  else {
    lVar2 = ptrace(PTRACE_TRACEME);
    if (lVar2 == -1) {
      puts("\x1b[32m.---------------------------.");
      puts("\x1b[31m| !! TAMPERING DETECTED !!  |");
      puts("\x1b[32m\'---------------------------\'");
      uVar1 = 1;
    }
    else {
      serial = ((int)param_1[3] ^ 0x1337U) + 0x5eeded;
      for (local_18 = 0; local_18 < (int)username; local_18 = local_18 + 1) {
        if (param_1[local_18] < 32) {
          return 1;
        }
        serial = serial + ((int)param_1[local_18] ^ serial) % 0x539;
      }
      if (param_2 == serial) {
        uVar1 = 0;
      }
      else {
        uVar1 = 1;
      }
    }
  }
  return uVar1;
}

```

Coding a solution in C

Sorry I didn't feel like making arguments. this will generate a valid serial for the user "username".
just supply the output to the challenge binary and we finally spawn a shell
```
#include <stdio.h>
#include <string.h>

int main()
{
  char user[] = "username";
  int serial =  (user[3] ^ 0x1337) + 0x5eeded;
  int len = strlen(user);
    for (int i=0; i < len; i ++)
    {
        serial = serial + (user[i] ^ serial) % 0x539;
        
    }
    printf("%d",serial);

    return 0;
}
```

```
.---------------------------.
|---------  RPISEC  --------|
|+ SECURE LOGIN SYS v. 3.0 +|
|---------------------------|
|~- Enter your Username:  ~-|
'---------------------------'
username
.---------------------------.
| !! NEW ACCOUNT DETECTED !!|
|---------------------------|
|~- Input your serial:    ~-|
'---------------------------'
6234463       
Authenticated!
```
